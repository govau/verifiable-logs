// Code generated by protoc-gen-go. DO NOT EDIT.
// source: metadata.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// LogMetadata is stored per log and contains the private key
type LogMetadata struct {
	// ASN.1 DER encoded ECDSA private key
	PrivateKeyDer        []byte   `protobuf:"bytes,2,opt,name=private_key_der,json=privateKeyDer,proto3" json:"private_key_der,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogMetadata) Reset()         { *m = LogMetadata{} }
func (m *LogMetadata) String() string { return proto.CompactTextString(m) }
func (*LogMetadata) ProtoMessage()    {}
func (*LogMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_metadata_de9d981201922ce7, []int{0}
}
func (m *LogMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogMetadata.Unmarshal(m, b)
}
func (m *LogMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogMetadata.Marshal(b, m, deterministic)
}
func (dst *LogMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogMetadata.Merge(dst, src)
}
func (m *LogMetadata) XXX_Size() int {
	return xxx_messageInfo_LogMetadata.Size(m)
}
func (m *LogMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LogMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LogMetadata proto.InternalMessageInfo

func (m *LogMetadata) GetPrivateKeyDer() []byte {
	if m != nil {
		return m.PrivateKeyDer
	}
	return nil
}

// SignedTreeHead is persisted for each tree size that it is requested
// for. In theory we could store only the last, however for now we'll keep all.
// The fields here are as per https://tools.ietf.org/html/rfc6962#section-3.5
type SignedTreeHead struct {
	TreeSize             int64    `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	Timestamp            int64    `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Sha256RootHash       []byte   `protobuf:"bytes,3,opt,name=sha256_root_hash,json=sha256RootHash,proto3" json:"sha256_root_hash,omitempty"`
	TreeHeadSignature    []byte   `protobuf:"bytes,4,opt,name=tree_head_signature,json=treeHeadSignature,proto3" json:"tree_head_signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignedTreeHead) Reset()         { *m = SignedTreeHead{} }
func (m *SignedTreeHead) String() string { return proto.CompactTextString(m) }
func (*SignedTreeHead) ProtoMessage()    {}
func (*SignedTreeHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_metadata_de9d981201922ce7, []int{1}
}
func (m *SignedTreeHead) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedTreeHead.Unmarshal(m, b)
}
func (m *SignedTreeHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedTreeHead.Marshal(b, m, deterministic)
}
func (dst *SignedTreeHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTreeHead.Merge(dst, src)
}
func (m *SignedTreeHead) XXX_Size() int {
	return xxx_messageInfo_SignedTreeHead.Size(m)
}
func (m *SignedTreeHead) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTreeHead.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTreeHead proto.InternalMessageInfo

func (m *SignedTreeHead) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *SignedTreeHead) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SignedTreeHead) GetSha256RootHash() []byte {
	if m != nil {
		return m.Sha256RootHash
	}
	return nil
}

func (m *SignedTreeHead) GetTreeHeadSignature() []byte {
	if m != nil {
		return m.TreeHeadSignature
	}
	return nil
}

// AddResponse is stored per objecthash and is so that multiple submissions
// to the log with the same objecthash return the same SCT.
// i.e. the fields here are as per https://tools.ietf.org/html/rfc6962#section-3.2
type AddResponse struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Signature            []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddResponse) Reset()         { *m = AddResponse{} }
func (m *AddResponse) String() string { return proto.CompactTextString(m) }
func (*AddResponse) ProtoMessage()    {}
func (*AddResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_metadata_de9d981201922ce7, []int{2}
}
func (m *AddResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddResponse.Unmarshal(m, b)
}
func (m *AddResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddResponse.Marshal(b, m, deterministic)
}
func (dst *AddResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddResponse.Merge(dst, src)
}
func (m *AddResponse) XXX_Size() int {
	return xxx_messageInfo_AddResponse.Size(m)
}
func (m *AddResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddResponse proto.InternalMessageInfo

func (m *AddResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AddResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*LogMetadata)(nil), "au.gov.digital.verifiabledatastructures.LogMetadata")
	proto.RegisterType((*SignedTreeHead)(nil), "au.gov.digital.verifiabledatastructures.SignedTreeHead")
	proto.RegisterType((*AddResponse)(nil), "au.gov.digital.verifiabledatastructures.AddResponse")
}

func init() { proto.RegisterFile("metadata.proto", fileDescriptor_metadata_de9d981201922ce7) }

var fileDescriptor_metadata_de9d981201922ce7 = []byte{
	// 275 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x90, 0x3f, 0x4f, 0xf3, 0x30,
	0x10, 0xc6, 0x95, 0xa6, 0x7a, 0xf5, 0xc6, 0x85, 0x00, 0x66, 0x89, 0x44, 0x87, 0x2a, 0x03, 0x64,
	0xca, 0x00, 0x2a, 0x3b, 0x88, 0xa1, 0x08, 0x58, 0x12, 0x26, 0x16, 0xeb, 0x82, 0x8f, 0xc4, 0xa2,
	0x89, 0x23, 0xfb, 0x12, 0xa9, 0xfd, 0x3e, 0x7c, 0x4f, 0x14, 0x37, 0x28, 0x52, 0xd7, 0x9f, 0x1f,
	0x3f, 0x7f, 0x8e, 0x85, 0x35, 0x12, 0x48, 0x20, 0x48, 0x5b, 0xa3, 0x49, 0xf3, 0x1b, 0xe8, 0xd2,
	0x52, 0xf7, 0xa9, 0x54, 0xa5, 0x22, 0xd8, 0xa6, 0x3d, 0x1a, 0xf5, 0xa5, 0xa0, 0xd8, 0xe2, 0x20,
	0xb2, 0x64, 0xba, 0x4f, 0xea, 0x0c, 0xda, 0x78, 0xcd, 0x16, 0xaf, 0xba, 0x7c, 0x1b, 0x7f, 0xf3,
	0x6b, 0x76, 0xd6, 0x1a, 0xd5, 0x03, 0xa1, 0xf8, 0xc6, 0x9d, 0x90, 0x68, 0xa2, 0xd9, 0xca, 0x4b,
	0x4e, 0xb2, 0xd3, 0x11, 0xbf, 0xe0, 0xee, 0x09, 0x4d, 0xfc, 0xe3, 0xb1, 0x30, 0x57, 0x65, 0x83,
	0xf2, 0xdd, 0x20, 0x6e, 0x10, 0x24, 0xbf, 0x62, 0x01, 0x19, 0x44, 0x61, 0xd5, 0x1e, 0x23, 0x6f,
	0xe5, 0x25, 0x7e, 0xf6, 0x7f, 0x00, 0xb9, 0xda, 0x23, 0x5f, 0xb2, 0x80, 0x54, 0x8d, 0x96, 0xa0,
	0x6e, 0x9d, 0xa3, 0x9f, 0x4d, 0x80, 0x27, 0xec, 0xdc, 0x56, 0x70, 0xbb, 0xbe, 0x17, 0x46, 0x6b,
	0x12, 0x15, 0xd8, 0x2a, 0xf2, 0x5d, 0x6c, 0x78, 0xe0, 0x99, 0xd6, 0xb4, 0x01, 0x5b, 0xf1, 0x94,
	0x5d, 0xba, 0x90, 0x0a, 0x41, 0x0a, 0xab, 0xca, 0x06, 0x86, 0x19, 0xd1, 0xdc, 0x89, 0x2f, 0x68,
	0xec, 0x92, 0xff, 0x3d, 0xc4, 0xcf, 0x6c, 0xf1, 0x20, 0x65, 0x86, 0xb6, 0xd5, 0x8d, 0x3d, 0xaa,
	0xe1, 0x1d, 0xd7, 0x58, 0xb2, 0x60, 0xb2, 0x3c, 0xcc, 0x9e, 0xc0, 0xe3, 0xfc, 0x63, 0xd6, 0x16,
	0xc5, 0x3f, 0x77, 0xdf, 0xbb, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x16, 0x0e, 0xd5, 0x71,
	0x01, 0x00, 0x00,
}
